<?php

namespace Plugin\CustomerTracker\Repository;

use Doctrine\ORM\EntityRepository;
use Doctrine\ORM\NoResultException;
use Doctrine\ORM\Query\Expr\GroupBy;
use Doctrine\ORM\Query\Expr\OrderBy;

/**
 * HistoryRepository
 *
 * This class was generated by the Doctrine ORM. Add your own custom
 * repository methods below.
 */
class HistoryRepository extends EntityRepository
{

    public function findLastOne($history)
    {
        $q = $this->createQueryBuilder('h')
            ->andWhere("h.session_id = :sessionId")
            ->setMaxResults(1)
            ->orderBy('h.visited', 'DESC')
            ->setParameter('sessionId', $history->getSessionId());
        if ($history->getId()) {
            $q->andWhere("h.id < :historyId")->setParameter('historyId', $history->getId());
        }
        $q = $q->getQuery();
        
        try {
            $result = $q->getSingleResult();
            return $result;
        } catch (NoResultException $e) {
            // 結果がない場合は空の配列を返す.
            return null;
        }
    }

    public function getActiveCount($timelimit)
    {
        $qb = $this->createQueryBuilder('h')
            ->select('distinct h.session_id')
            ->where('h.visited > :visited_expire')
            ->setParameter('visited_expire', (new \DateTime())->sub(new \DateInterval('PT' . $timelimit . 'S')));
        
        $result = $qb->getQuery()->getResult();
        if ($result)
            return sizeof($result);
        else
            return 0;
    }

    public function getGroupedHistory($timeRange)
    {
        $qb = $this->createQueryBuilder('h')
            ->where('h.visited > :visited_expire')
            ->setParameter('visited_expire', (new \DateTime())->sub(new \DateInterval('PT' . $timeRange . 'S')))
            ->addOrderBy('h.session_id', 'asc')
            ->addOrderBy('h.visited', 'desc');
        return $this->groupResult($qb->getQuery()
            ->getResult());
    }

    public function getLatestHistoryGroups($latestHistoryId)
    {
        $qb = $this->createQueryBuilder('h')
            ->where('h.id > :latestHistoryId')
            ->setParameter('latestHistoryId', $latestHistoryId)
            ->addOrderBy('h.session_id', 'asc')
            ->addOrderBy('h.visited', 'desc');
        $groups = $this->groupResult($qb->getQuery()
            ->getResult());
        return $groups;
    }
    
    public function getUriRelations($groupedHistory)
    {
        $nodes = array();
        $links = array();
        if ($groupedHistory) {
            foreach ($groupedHistory as $key => $histories) {
                foreach ($histories as $history) {
                    $uri = $history->getUri();
                    if ($nodes[$uri]) {
                        $nodes[$uri] += 1;
                    } else {
                        $nodes[$uri] = 1;
                    }
                    $prevUri = $history->getPrevUri();
                    if ($prevUri && $prevUri != $uri) {
                        if ($links[$prevUri] && $links[$prevUri][$uri]) {
                            $links[$prevUri][$uri] += 1;
                        } else {
                            if (!$links[$prevUri])
                                $links[$prevUri] = array();
                            $links[$prevUri][$uri] = 1;
                        }
                    }
                }
            }
        }
        
        foreach ($links as $uri1 => $link) {
            if (!$nodes[$uri1]) {
                $nodes[$uri1] = 0;
            }
        }
        
        $newnodes = array();
        $newlinks = array();
        $idx = 0;
        foreach ($nodes as $uri => $count) {
            $newnodes[$uri] = array('name'=>$uri, 'cnt'=>$count, 'idx' => $idx++);
        }
        foreach ($nodes as $uri => $count) {
            if ($links[$uri]) {
                foreach ($links[$uri] as $uri2 => $count2) {
                    $idx1 = $newnodes[$uri]['idx'];
                    if (!$newnodes[$uri2]) {
                        $newnodes[$uri2] = array('name'=>$uri2, 'cnt'=>0, 'idx' => $newnodes.length);
                    }
                    $idx2 = $newnodes[$uri2]['idx'];
                    $newlinks[] = array('source'=>$idx1, 'target'=>$idx2, 'weight'=>$count2);
                }
            }
        }
        
        return array("nodes"=>array_values($newnodes), "links"=>$newlinks);
    }
    
    public function getLatestUriRelations($latestHistoryId)
    {
        $nodes = array();
        $links = array();
        $groups = getLatestHistoryGroups($latestHistoryId);
        if ($groups) {
            foreach ($groups as $key => $histories) {
                $lasturi = '';
                foreach ($histories as $history) {
                    $uri = $history->getUri();
                    if ($nodes[$uri]) {
                        $nodes[$uri] += 1;
                    } else {
                        $nodes[$uri] = 1;
                    }
                    if ($lasturi && $lasturi != $uri) {
                        if ($links[$lasturi] && $links[$lasturi][$uri]) {
                            $links[$lasturi][$uri] += 1;
                        } else {
                            if (!$links[$lasturi])
                                $links[$lasturi] = array();
                            $links[$lasturi][$uri] = 1;
                        }
                    }
                    $lasturi = $uri;
                }
            }
        }
        $newnodes = array();
        $newlinks = array();
        $idx = 0;
        foreach ($nodes as $uri => $count) {
            $newnodes[$uri] = array('name'=>$uri, 'cnt'=>$count, 'idx' => $idx++);
        }
        foreach ($nodes as $uri => $count) {
            if ($links[$uri]) {
                foreach ($links[$uri] as $uri2 => $count2) {
                    $idx1 = $newnodes[$uri]['idx'];
                    if (!$newnodes[$uri2]) {
                        $newnodes[$uri2] = array('name'=>$uri2, 'cnt'=>1, 'idx' => $newnodes.length);
                    }
                    $idx2 = $newnodes[$uri2]['idx'];
    
                    $newlinks[] = array('source'=>$idx1, 'target'=>$idx2, 'weight'=>$count2);
                }
            }
        }
    
    
        return array("nodes"=>array_values($newnodes), "links"=>$newlinks);
    }
    

    protected function groupResult($results)
    {
        if ($results) {
            $groups = array();
            $lastSessionId = null;
            $histories = array();
            foreach ($results as $history) {
                $sessionId = $history->getSessionId();
                if ($sessionId != $lastSessionId) {
                    if ($lastSessionId != null) {
                        $groups[$lastSessionId] = $histories;
                        $histories = array();
                    }
                    $lastSessionId = $sessionId;
                }
                $histories[] = $history;
            }
            if ($lastSessionId != null) {
                $groups[$lastSessionId] = $histories;
            }
            uasort($groups, 'self::sortHistory');
            return $groups;
        } else {
            return null;
        }
    }

    private static function sortHistory($a, $b)
    {
        $ha = $a[0];
        $hb = $b[0];
        if ($ha->getVisited() == $hb->getVisited()) {
            return 0;
        }
        return ($ha->getVisited() > $hb->getVisited()) ? - 1 : 1;
    }
}
